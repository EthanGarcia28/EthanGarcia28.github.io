---
layout: essay
type: essay
title: "The Cost of Thinking in Software Projects"
date: 2025-12-12
published: true
labels:
  - Software Engineering
  - Effort Estimation
  - Time Tracking
---

# <img width="220px" class="rounded float-start pe-4" src="../img/effort-estimation.png">

Software development rarely takes exactly as long as we expect it to. Early in this project, I learned that effort estimation is less about predicting the future and more about understanding how I actually work. By estimating tasks, tracking my time, and reflecting on the differences between the two, I gained a clearer picture of where effort truly goes.

## How I Formed My Estimates

My initial effort estimates were based on experience from previous assignments and WODs (Workouts of the Day), completed throughout the course. These WODs are short, timed exercises that emphasize practicing specific technical skills under a time restriction, making them a useful reference when estimating larger tasks. When I encountered a new task, I mentally compared it to similar work I had already completed and adjusted my estimate depending on how familiar I was with the tools or concepts involved. 

One example was a task that required building a meeting and calendar data model along with the related backend functions. I had worked on similar features before, but not at the same level of integration, so I assumed the task would take around four hours. That estimate felt reasonable based on my prior experience, even though I later learned it did not capture the full scope of the effort involved.

## Why Estimating Still Helped

In practice, the task took about three and a half hours of direct coding time, plus roughly an additional hour spent planning, researching, and debugging. Although the estimate was off, the act of estimating still proved valuable. Estimating forced me to think through the task before starting and break it into manageable pieces rather than approaching it as a single block of work.

By outlining steps such as designing the data model, implementing functions, testing behavior, and addressing edge cases, I was able to work more deliberately and avoid feeling overwhelmed. Even when my estimate was inaccurate, the structure it provided helped me maintain momentum and manage my time more effectively.

## What Time Tracking Revealed

Tracking my actual effort made it clear why my estimates were consistently optimistic. A significant portion of my time was not spent writing code, but thinking through solutions, reading documentation, experimenting with approaches, and fixing mistakes. These activities are easy to overlook when estimating, yet they often determine how long a task truly takes.

Seeing this pattern repeated across multiple tasks helped me understand that my workflow includes substantial effort. That realization alone made time tracking worthwhile, because it gave me concrete evidence of where my time was going rather than relying on vague impressions.

## Tracking Effort in Practice

I tracked my effort using a simple Google timer, starting it when I began working and pausing it whenever I stepped away or took a break. This low-friction approach made it easy to stay consistent without disrupting my workflow. While it is not perfect, I believe the tracking was reasonably accurate because I made a conscious effort to stop the timer during interruptions and only run it during focused work sessions.

The simplicity of the method turned out to be one of its strengths. Because it required minimal setup and maintenance, I was more likely to use it regularly, which made the data more reliable over time.

## Lessons for Future Projects

If I were to change one thing about my estimation process, it would be to explicitly plan for non-coding work. My estimates tended to assume that most of the effort would be spent implementing solutions, when in reality, much of it was spent preparing to implement them. In future projects, I would break tasks down into categories such as research, design, implementation, and debugging, rather than treating everything as coding time.

This adjustment would not only improve estimation accuracy but also reduce frustration when tasks take longer than expected for reasons that are entirely normal in software development.

## Using AI as a Supporting Tool

I also relied on AI tools, including ChatGPT and GitHub Copilot, when estimating and implementing tasks that felt unfamiliar or complex. ChatGPT helped me sanity-check assumptions about task scope and provided alternative ways to think about breaking work into steps, while GitHub Copilot helped speed up implementation by suggesting boilerplate code and common patterns.

These tools did not replace my judgment, but they did help me form more informed estimates. I spent a small amount of time refining prompts, reviewing responses, and adjusting the suggestions to fit my own skill level and understanding. In most cases, the high-level guidance was useful as-is, while specific details required manual correction.

## Conclusion

Effort estimation did not make my predictions perfect, but it made my work more intentional. Estimating ahead of time encouraged structure, tracking revealed hidden effort, and reflecting on both helped me understand my development habits more clearly. By accounting for non-coding work and using AI tools as support rather than shortcuts, I am better prepared to plan, estimate, and execute future software projects with greater confidence.
